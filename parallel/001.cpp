// My first implementation of a STATIC PIPELINE
// The safe_queue implementation idea was presented in classroom
// For the remaining part license, contact Michele Miccinesi
// You'll find me on git

// You can easily use it with many containers (just adjusting
// the eventually different syntaxes ), or refine the definition,
// as an example you could specify more parameters to the lambda
// functions, or we could divide in prologue_function, while_function,
// epilogue function etc... Here I somewhat constrained it too much
// to keep the code short for the assignment

// Number of stages = number of additional threads

// N.B. This is the non polished version, just to play with the idea!

#include <iostream>
#include <thread>
#include <mutex>
#include <condition_variable>
#include <vector>
#include <queue>
#include <functional>
//for testing
#include <random> 	
#include <cmath>
#include <iomanip>

const int LENGTH_STREAM = 500;		//soo LENGTH_STREAM vectors will be generated by the source
const int LENGTH_VECTOR = 100;

//userend ACHTUNG: never pass references or pointers to elements of safe_queue<T>::_queue
template <typename T>
class safe_queue{
	std::mutex _mutex;
	std::condition_variable _condition;
	std::queue<T> _queue;
public:
	safe_queue() : _queue() {}
	
	void push(const T& x){
		{
			std::unique_lock<std::mutex> lock(_mutex);
			_queue.push(x);
		}
		_condition.notify_one();
	}
	
	T pop(){
		std::unique_lock<std::mutex> lock(_mutex);
		_condition.wait(lock, [=]{ return !_queue.empty(); });
		T x(std::move(_queue.front()));
		_queue.pop();
		return x;
	}
};


/* The dummy_stage is inherited by all stages; it works as a filter to 	*/
/* pass to the stages the necessary arguments from pipeline, which is  	*/
/* friend of the relative dummy_stage 								   	*/
template <class Pipe>
class dummy_stage{
protected:
	Pipe *pipe;
	std::vector<std::thread>& threads;
public:	
	dummy_stage(Pipe *_pipe) : pipe(_pipe), threads(pipe->threads) {}
};

template <class Pipe, class ...Args>
class pipe_stage {};

//DRAIN
template <class Pipe, class Tin, class F>
class pipe_stage<Pipe, Tin, F> : public dummy_stage<Pipe> {
	F _f;
	void _run(){
		while(true){
			Tin* data( inQ.pop() );
			if( data!=nullptr ){
				for( auto &x: *data )
					_f(x);
				delete data;

				std::cout << std::endl;
			} else {
				return;
			}
		}
	}
protected:
	safe_queue<Tin*> inQ;
public:
	pipe_stage(Pipe *_pipe, F f) : dummy_stage<Pipe>(_pipe), _f(f), inQ()
	{
		this->threads.emplace_back(&pipe_stage<Pipe, Tin, F>::_run, this);
	}
};

//MID STAGES
template <class Pipe, class Tin, class F, class Tout, class ... Args>
class pipe_stage<Pipe, Tin, F, Tout, Args ...> : public pipe_stage<Pipe, Tout, Args ...> {
	F _f;
	void _run(){
		while(true){
			//for plain C++, use std::unique_pointer
			Tin* data( inQ.pop() );
			if( data!=nullptr ){
				Tout *out_data = new Tout;
				out_data->reserve( data->size() );
				for( auto &x: *data )
					out_data->emplace_back(_f(x));
				delete data;
				outQ.push(out_data);
			} 
			else {
				outQ.push( nullptr );
				return;
			}
		}
	}
	safe_queue<Tout*>& outQ;
protected:
	safe_queue<Tin*> inQ;
public:
	template <class ...Fs>
	pipe_stage(Pipe *_pipe, F f, Fs ... fs)
	: pipe_stage<Pipe, Tout, Args ...>(_pipe, fs ... ), _f(f), outQ(pipe_stage<Pipe, Tout, Args ...>::inQ), inQ() 
	{
		this->threads.emplace_back(&pipe_stage<Pipe, Tin, F, Tout, Args ...>::_run, this);
	}
};

template <class Pipe, class F, class Tout, class ... Args>
class pipe_source : protected pipe_stage<Pipe, Tout, Args...>{
	safe_queue<Tout*>& outQ;
	F _f;
	int _n;		//# cycles ...just to make it simple!!
	unsigned int _size;
	void _run(){
		while( _n-- ){
			Tout* out_data = new Tout(_size);
			for( auto &x: *out_data )
				x = _f();
			outQ.push(out_data);
		}
		outQ.push(nullptr);
	}
public:	
	template <class ...Fs>
	pipe_source(int n, unsigned int size, Pipe* _pipe, F f, Fs ... fs)
	: pipe_stage<Pipe, Tout, Args ...>(_pipe, fs...), outQ(pipe_stage<Pipe, Tout, Args ...>::inQ), _f(f), _n(n), _size(size) 
	{
		//_run(); // if you want to launch the pipe SOURCE in the thread which constructed the class
		this->threads.emplace_back(&pipe_source::_run, this);
	}
};


template <class ...Args>
class pipeline{
	std::vector<std::thread> threads;
	friend class dummy_stage<pipeline<Args ...>>;
	pipe_source<pipeline<Args...>, Args ...> stages; 	
public:
	template <class F0, class F1, class ... Fs>
	explicit pipeline(int n, int size, F0 f0, F1 f1, Fs ...fs) :
	threads(), stages(n, size, this, f0, f1, fs ... )
	{
	}

	void join(){
		for( auto & thr: threads ){
			if( thr.joinable() )
				thr.join();
		}
	}

	void detach(){
		for( auto & thr: threads ){
			if( thr.joinable() )
				thr.detach();
		}
	}

	~pipeline(){
		join();
	}
};

/* Example (first assignment for the course SPM1718 at unipi ) */
int main(){
	std::ios_base::sync_with_stdio(false);

	std::random_device r; 

    std::seed_seq seed1{r(), r(), r(), r(), r(), r(), r(), r()};
    std::mt19937 e1(seed1);
    std::uniform_real_distribution<double> uniformDist(-1, 1);

    auto f0 = [&e1, &uniformDist]{ 
    	double a = uniformDist(e1);
    	return a;
    };

    auto f1 = [](double a)->double{
    	return a+1.;
    };

    auto f2 = [](double a)->double{
    	return 2.*a;
    };

	auto f3 = [](double a){
		std::cout << std::fixed << a << ' ';
	};

	typedef std::vector<double> dv;
	pipeline<decltype(f0), dv, decltype(f1), dv, decltype(f2), dv, decltype(f3)> myPipe(LENGTH_STREAM, LENGTH_VECTOR, f0, f1, f2, f3);

	return 0;
}
